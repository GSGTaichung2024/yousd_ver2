
/*!
 * jQuery Arts Cursor v1.0.0
 * 
 * @author: Artem Semkin
 * Â© 2021 All rights reserved.
 */

!function(n){"function"==typeof define&&define.amd?define(["jquery"],n):"object"==typeof module&&module.exports?module.exports=function(e,u){return void 0===u&&(u="undefined"!=typeof window?require("jquery"):require("jquery")(e)),n(),u}:n(jQuery)}(function(e){"use strict";
// Default Options
const defaults = {
	target: {
		cursor: '[data-arts-cursor]',
		magnetic: '[data-arts-cursor-magnetic]',
		highlight: 'a:not(a[data-arts-cursor]):not(.social__item a):not(a.page-numbers):not(.js-arts-cursor-no-highlight), .js-arts-cursor-highlight, button:not(button[data-arts-cursor])',
		hideNative: '[data-arts-cursor-hide-native]',
		hideScaleMagnetic: '.slider__dot, .social__item, a.page-numbers',
	},
	elements: {
		follower: '.js-arts-cursor__follower',
		stroke: {
			inner: '.js-arts-cursor__stroke-inner',
			outer: '.js-arts-cursor__stroke-outer',
		},
		arrow: {
			up: '.js-arts-cursor__arrow-up',
			down: '.js-arts-cursor__arrow-down',
			left: '.js-arts-cursor__arrow-left',
			right: '.js-arts-cursor__arrow-right',
		},
		container: {
			label: '.js-arts-cursor__label',
			icon: '.js-arts-cursor__icon'
		}
	},
	effect: {
		highlight: {
			scale: 1.5
		},
		magnetic: {
			scale: 1.3,
			scaleBy: 'element'
		},
		arrows: {
			distance: 45
		},
		trailing: 6,
		animationDuration: 0.25
	},
	labels: {
		slider: 'Drag'
	}
};

class ArtsCursor {

	constructor(element, options) {
		// Main container element
		this.$el = $(element);

		if (!this.$el.length) {
			return;
		}

		// Merge user settings with default
		this.dataOptions = {

		};
		this.options = $.extend(true, {}, defaults, options, this.dataOptions);

		this.$scope = $(document);
		this.$body = $('body');
		this.timeline = new gsap.timeline();
		this.timelineArrows = new gsap.timeline();
		this.timelineLoading = new gsap.timeline();

		this.$follower = this.$el.find(this.options.elements.follower);
		this.$inner = this.$el.find(this.options.elements.stroke.inner);
		this.$outer = this.$el.find(this.options.elements.stroke.outer);

		// Arrows
		this.$arrowUp = this.$el.find(this.options.elements.arrow.up);
		this.$arrowDown = this.$el.find(this.options.elements.arrow.down);
		this.$arrowLeft = this.$el.find(this.options.elements.arrow.left);
		this.$arrowRight = this.$el.find(this.options.elements.arrow.right);

		this.$label = this.$el.find(this.options.elements.container.label);
		this.$icon = this.$el.find(this.options.elements.container.icon);
		this.savedIconClasses = this.$icon.attr('class');

		this.offsetTop = parseFloat($('html').css('marginTop'));
		this.animDuration = parseFloat(this.options.effect.animationDuration);
		this.mouseX = window.mouseX || 0;
		this.mouseY = window.mouseY || 0;
		this.magneticX = 0;
		this.magneticY = 0;
		this.scale = 1;
		this.posX = 0;
		this.posY = 0;
		this.width = this.$el.innerWidth();
		this.height = this.$el.innerHeight();
		this.size = Math.max(this.width, this.height);
		this.cursorCenterX = parseFloat(this.width / 2);
		this.cursorCenterY = parseFloat(this.height / 2);
		this.isFirstMove = true;
		this.isDragging = false;

		this.cursorElements = this.options.target.cursor;

		this.highlightElements = this.options.target.highlight;
		this.highlightScale = parseFloat(this.options.effect.highlight.scale);

		this.magneticElements = this.options.target.magnetic;
		this.$magneticElements = $(this.options.target.magnetic);
		this.magneticScale = parseFloat(this.options.effect.magnetic.scale);
		this.magneticScaleCursorBy = this.options.effect.magnetic.scaleBy;
		this.hideScaleMagneticElements = this.options.target.hideScaleMagnetic;

		this.factorTrailing = parseFloat(this.options.effect.trailing);
		this.label = '';
		this.icon = '';
		this.distanceArrows = parseFloat(this.options.effect.arrows.distance);
		this.strokeColor = this.$inner.css('stroke');
		this.strokeWidth = parseFloat(this.$inner.css('stroke-width'));

		// Initial load
		this._init();
	}

	// Initial Method
	_init() {
		gsap.set(this.$el, {
			display: 'block',
		});

		gsap.to(this.$el, {
			duration: 0.6,
			scale: 1,
			autoAlpha: 1,
			xPercent: 0,
			yPercent: 0,
		});

		gsap.to({}, {
			duration: 0.01,
			repeat: -1,
			onRepeat: () => {
				const trailing = this.isFirstMove ? 1 : this.factorTrailing;
				this.posX += (this.mouseX - this.posX) / trailing;
				this.posY += (this.mouseY - this.posY - this.offsetTop) / trailing;

				gsap.set(this.$el, {
					xPercent: 0,
					yPercent: 0,
					x: this.posX - this.cursorCenterX,
					y: this.posY - this.cursorCenterY,
					repeat: -1,
				});
				this.isFirstMove = false;
			}
		});

		this._bindEvents();
	}

	_bindEvents() {
		const self = this;

		this.$scope.off('mousemove mouseenter mouseleave')
			.on('mousemove', (e) => {
				this.mouseX = this.magneticX || e.clientX;
				this.mouseY = this.magneticY || e.clientY;
			})
			// PSWP gallery
			.on('mousemove', '.pswp--zoomed-in .pswp__img', (e) => {
				this._setCursor({
					hide: false
				});
				this._setIcon({
					icon: '',
					hide: true
				});
				this.scale = 1.0;
				this._scaleCursor();
			})
			.on('mousemove', '.pswp--dragging .pswp__img', (e) => {
				this.scale = 1.0;
				this._scaleCursor();
			})
			// cursor elements
			.on('mouseenter', self.cursorElements, (e) => {
				if (self.isDragging) {
					return;
				}

				const
					$target = $(e.currentTarget),
					label = $target.attr('data-arts-cursor-label') || '',
					hide = $target.attr('data-arts-cursor-hide-native') ? true : false,
					icon = $target.attr('data-arts-cursor-icon-class') || '';

				let
					scale = $target.attr('data-arts-cursor-scale'),
					color = $target.attr('data-arts-cursor-color') || '',
					background = $target.attr('data-arts-cursor-background-color') || '';

				if (color === 'current') {
					color = $target.css('color');
				}

				if (background === 'current') {
					background = $target.css('background-color');
				}

				if (scale === 'current') {
					const { width, height } = e.currentTarget.getBoundingClientRect();
					const size = Math.max(width, height);
					this.scale = size / self.size;
				} else {
					this.scale = scale;
				}

				this._highlightCursor({
					highlight: false,
					background
				});

				this._setCursor({
					hide
				});

				this._setLabel({
					label,
					color,
					background,
				});

				this._setIcon({
					icon,
					color,
					background,
				});

				this._hideArrows();

				this._scaleCursor();
			})
			.on('mouseleave', self.cursorElements, () => {

				this._setCursor({
					hide: false
				});

				this._highlightCursor({
					highlight: false
				});

				if (!self.isDragging) {
					this.scale = 1;
					this._scaleCursor();

					this._setIcon({
						icon: '',
						hide: true
					});

					this._setLabel({
						label: '',
						hide: true
					});
				}
			})
			// highlight elements
			.on('mouseenter', self.highlightElements, (e) => {
				if (!self.isDragging) {
					this.scale = parseFloat(this.highlightScale);
					this._highlightCursor({
						highlight: true
					});
					this._scaleCursor();
				}
			})
			.on('mouseleave', self.highlightElements, (e) => {
				this._highlightCursor({
					highlight: false
				});

				if (!self.isDragging) {
					this.scale = 1;
					this._scaleCursor();
				}
			})
			// magnetic elements
			.on('mousemove', self.magneticElements, (e) => {
				const $target = $(e.currentTarget);

				if (self.isDragging) {
					this._resetMagnifiedElement($target);
					return;
				} else {
					this._magnifyElement({
						element: $target,
						event: e,
						distance: self.magneticDistance,
						scaleBy: self.magneticScaleCursorBy,
						scale: parseFloat($target.attr('data-arts-cursor-scale')) || this.magneticScale,
					});
				}
			})
			.on('mouseleave', self.magneticElements, (e) => {
				this._resetMagnifiedElement($(e.currentTarget));
			})
			.on('mouseenter', self.hideScaleMagneticElements, (e) => {
				if (!self.isDragging) {
					const { width, height } = e.currentTarget.getBoundingClientRect();
					const size = Math.max(width, height);
					this.scale = size / self.size;

					this._scaleCursor();
				}

				this._setCursor({
					hide: true
				});
			})
			.on('mouseleave', self.hideScaleMagneticElements, (e) => {
				this._setCursor({
					hide: false
				});

				if (!self.isDragging) {
					this.scale = 1;
					this._scaleCursor();
				}

				this._resetMagnifiedElement($(e.currentTarget));
			})
			.on('mousemove', self.hideScaleMagneticElements, (e) => {
				const $target = $(e.currentTarget);

				this._magnifyElement({
					element: $target,
					event: e,
					distance: self.magneticDistance,
					scaleBy: self.magneticScaleCursorBy,
					// scale: 1,
				});
			});

		this.$el
			.on('startLoading', () => {
				this._drawLoading();
				this._resetCursor();
			})
			.on('finishLoading', () => {
				this._finishLoading();
				this._resetCursor();
			})
			.on('hide', () => {
				this.scale = 0;
				this._scaleCursor();
			})
			.on('show', () => {
				this._resetCursor();
			})
			.on('disable', () => {
				this.$el.off('startLoading finishLoading hide show');
				this.$scope.off('mousemove mouseenter mouseleave');
			})
			.on('enable', () => {
				this.$el.off('startLoading finishLoading hide show');
				this.$scope.off('mousemove mouseenter mouseleave');
				this._resetCursor();
				this._bindEvents();
			})
			.on('reset', () => {
				this._resetCursor();
			})
			.on('startDragging', (e) => {
				// this.$scope.trigger('mouseleave');
				this.isDragging = true;

				if ('hide' in e.detail) {
					this._setCursor({
						hide: e.detail.hide
					});
				}

				if ('label' in e.detail) {
					this.label = e.detail.label;
					this._setLabel({
						label: this.label
					});
				}

				if ('icon' in e.detail) {
					this.icon = e.detail.icon;
					this._setIcon({
						icon: this.icon,
						hide: false
					});
				}

				if ('direction' in e.detail) {
					this._revealArrows({
						direction: e.detail.direction,
						distance: e.detail.distance || 0
					});
				}

				if ('scale' in e.detail) {
					this.scale = e.detail.scale;
				} else {
					this.scale = 1.0;
				}

				this._scaleCursor();

				this._highlightCursor({
					highlight: false
				});
			})
			.on('finishDragging', (e) => {
				this.isDragging = false;

				this._setCursor({
					hide: false
				});
				this._setLabel({
					label: this.label,
					hide: true
				});
				this._setIcon({
					icon: this.icon,
					hide: true
				});
				this._hideArrows();
				this.scale = 1;
				this._scaleCursor();
			});
	}

	_drawLoading() {
		this.timelineLoading
			.fromTo(this.$outer, {
				autoAlpha: 1,
				drawSVG: '0%',
				rotate: 0,
			}, {
				drawSVG: '100%',
				ease: 'expo.inOut',
				transformOrigin: 'center center',
				rotate: 180,
				duration: 4
			});
	}

	_finishLoading() {
		this.timelineLoading
			.timeScale(8)
			.to(this.$outer, {
				autoAlpha: 0,
				duration: 4
			});
	}

	_scaleCursor() {
		let
			strokeWidth,
			delay = 0;

		if (this.scale === 1) {
			strokeWidth = this.strokeWidth;
		} else {
			strokeWidth = parseFloat(this.strokeWidth / this.scale);
			delay = this.animDuration * 1000 / 4;
		}

		gsap.to(this.$follower, {
			duration: this.animDuration,
			scale: this.scale,
			overwrite: 'all'
		});

		setTimeout(() => {
			this.$inner.css({
				strokeWidth
			});
		}, delay);
	}

	_highlightCursor({ highlight = true, background = '' }) {

		let
			color,
			opacity;

		if (background) {
			color = background;
			opacity = 1;
		} else {
			color = highlight ? this.strokeColor : '';
			opacity = highlight ? 0.4 : '';
		}

		gsap.to(this.$inner, {
			duration: this.animDuration,
			fill: color,
			stroke: color,
			opacity,
			overwrite: 'all'
		});
	}

	_setLabel({
		label = '',
		color = '',
		hide = false
	}) {
		this.$label.html(label);
		if (hide === true) {
			gsap.to(this.$label, {
				duration: this.animDuration,
				autoAlpha: 0,
				y: -20,
				clearProps: 'color'
			});
		} else {
			gsap.fromTo(this.$label, {
				autoAlpha: 0,
				y: -20,
				immediateRender: true
			},{
				duration: this.animDuration,
				autoAlpha: 1,
				y: 0,
				color
			});
		}
	}

	_setIcon({
		icon = '',
		color = '',
		hide = false
	}) {
		if (hide === true) {
			// reset class
			this.$icon.attr('class', this.savedIconClasses);

			gsap.to(this.$icon, {
				duration: this.animDuration,
				autoAlpha: 0,
				y: -20,
				clearProps: 'color'
			});
		} else {
			this.$icon.addClass(icon);
			gsap.to(this.$icon, {
				duration: this.animDuration,
				autoAlpha: 1,
				y: 0,
				color
			});
		}
	}

	_revealArrows({
		direction = 'horizontal',
		distance = 45
	}) {
		if (direction === 'horizontal') {
			this.timelineArrows
				.clear()
				.add([
					gsap.to(this.$arrowLeft, {
						duration: this.animDuration,
						autoAlpha: 1,
						x: -distance
					}),
					gsap.to(this.$arrowRight, {
						duration: this.animDuration,
						autoAlpha: 1,
						x: distance
					})
				]);
		}
		if (direction === 'vertical') {
			this.timelineArrows
				.clear()
				.add([
					gsap.to(this.$arrowUp, {
						duration: this.animDuration,
						autoAlpha: 1,
						y: -distance
					}),
					gsap.to(this.$arrowDown, {
						duration: this.animDuration,
						autoAlpha: 1,
						y: distance
					})
				]);
		}

		if (direction === 'all') {
			this.timelineArrows
				.clear()
				.add([
					gsap.to(this.$arrowUp, {
						duration: this.animDuration,
						autoAlpha: 1,
						y: -distance
					}),
					gsap.to(this.$arrowDown, {
						duration: this.animDuration,
						autoAlpha: 1,
						y: distance
					}),
					gsap.to(this.$arrowLeft, {
						duration: this.animDuration,
						autoAlpha: 1,
						x: -distance
					}),
					gsap.to(this.$arrowRight, {
						duration: this.animDuration,
						autoAlpha: 1,
						x: distance
					})
				]);
		}
	}

	_hideArrows() {
		this.timelineArrows
			.clear()
			.to([this.$arrowUp, this.$arrowDown, this.$arrowLeft, this.$arrowRight], {
				duration: this.animDuration,
				autoAlpha: 0,
				x: 0,
				y: 0
			});
	}

	_calcDistance({
		centerX,
		centerY,
		mouseX,
		mouseY
	}) {
		return Math.floor(
			Math.sqrt(
				Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2)
			)
		);
	}

	_resetMagnifiedElement(element) {
		this.magneticX = 0;
		this.magneticY = 0;

		if (element && element.length) {
			gsap.to(element, {
				duration: 0.4,
				y: 0,
				x: 0
			});
		}
	}

	_magnifyElement({
		element,
		event,
		distance,
		scale,
		scaleBy,
	}) {

		const {
			top,
			left,
			width,
			height
		} = element.get(0).getBoundingClientRect(),
			centerX = left + width / 2,
			centerY = top + height / 2,
			deltaX = Math.floor((centerX - event.clientX)) * -.5,
			deltaY = Math.floor((centerY - event.clientY)) * -.5;

		this.magneticX = centerX;
		this.magneticY = centerY;
		this.scale = scaleBy === 'element' ? Math.max(width, height) / this.cursorCenterX * scale : scaleBy * scale;

		gsap.to(element, {
			duration: 0.2,
			y: deltaY,
			x: deltaX,
			overwrite: 'all'
		});
	}

	_setCursor({
		hide = false,
		loading = false
	}) {

		if (this.isDragging) {
			this.$body.addClass('is-dragging arts-cursor-none');
		} else {
			this.$body.removeClass('is-dragging arts-cursor-none');
		}

		if (hide === true && !this.$body.hasClass('arts-cursor-none')) {
			this.$body.addClass('arts-cursor-none');
		} else {
			this.$body.removeClass('arts-cursor-none');
		}

		if (loading === true && !this.$body.hasClass('arts-cursor-progress')) {
			this.$body.addClass('arts-cursor-progress');
		} else {
			this.$body.removeClass('arts-cursor-progress');
		}
	}

	_resetCursor() {
		this._setCursor({
			hide: false
		});
		this._setLabel({
			label: '',
			hide: true
		});
		this._setIcon({
			icon: '',
			hide: true
		});
		this._hideArrows();
		this.scale = 1;
		this._scaleCursor();
		this._highlightCursor({
			highlight: false
		});
	}

}

// Wrapper for the plugin
$.fn.artsCursor = function (options) {
	const pluginName = 'artsCursor';

	if (typeof gsap === 'undefined') {
		console.error(`jQuery ${pluginName} plugin requires GSAP to work.`);
		return;
	}

	if (options === undefined || typeof options === 'object') {
		return this.each(function () {
			if (!$.data(this, pluginName)) {
				$.data(this, pluginName, new ArtsCursor(this, options));
			}
		});
	} else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
		const instance = $.data(this[0], pluginName);

		if (options === 'destroy') {
			$.data(this, pluginName, null);
		}

		if (instance instanceof ArtsCursor && typeof instance[options] === 'function') {
			return instance[options].apply(instance, Array.prototype.slice.call(arguments, 1));
		} else {
			return this;
		}
	}
};
});

