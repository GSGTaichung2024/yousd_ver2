
/*!
 * jQuery Arts Parallax v1.0.0
 * 
 * @author: Artem Semkin
 * Â© 2021 All rights reserved.
 */

!function(n){"function"==typeof define&&define.amd?define(["jquery"],n):"object"==typeof module&&module.exports?module.exports=function(e,u){return void 0===u&&(u="undefined"!=typeof window?require("jquery"):require("jquery")(e)),n(),u}:n(jQuery)}(function(e){"use strict";
// Default Options
const defaults = {
	target: {
		scrub: '.js-arts-parallax__scrub', // inner element to apply scrolling based effects
		velocity: '.js-arts-parallax__velocity', // inner element to scale
	},
	refreshPriority: 10
};

class ArtsParallax {

	constructor(element, options) {
		// Main container element
		this.$el = $(element);

		if (!this.$el.length) {
			return;
		}

		// Merge user settings with default
		this.dataOptions = {
			target: {
				// "innerElement" - transformation is applied to the nested element with class defined in	target.transform
				// "self" - transformation is applied to the currently selected element
				type: this.$el.attr('data-arts-parallax-target') || 'innerElement',
			},
			// Effects based on the current scroll position
			//
			scrubbing: {
				translate: {
					from: {
						x: this.$el.attr('data-arts-parallax-x-from') || 0.0,
						y: this.$el.attr('data-arts-parallax-y-from') || 0.0
					},
					to: {
						x: this.$el.attr('data-arts-parallax-x-to') || 0.0,
						y: this.$el.attr('data-arts-parallax-y-to') || 0.0
					},
				},
				scale: {
					from: this.$el.attr('data-arts-parallax-scale-from') || false, // Initial element scaling (ratio) before scene started
					to: this.$el.attr('data-arts-parallax-scale-to') || false // Target scaling (ratio) once scene finished
				},
				rotate: {
					from: this.$el.attr('data-arts-parallax-rotate-from') || false,
					to: this.$el.attr('data-arts-parallax-rotate-to') || false,
				},
				// Applied only if transform target is "innerElement".
				// Automatically calculates the required scaling ratio for the inner element depending on parallax distance.
				// The scaling is needed to prevent the element edges exposing while scrolling.
				factor: {
					x: this.$el.attr('data-arts-parallax-factor-x') || 0.0,
					y: this.$el.attr('data-arts-parallax-factor-y') || 0.0,
				}
			},
			scrub: this.$el.attr('data-arts-parallax-scrub') || true, // Scrubbing animation type only
							// "true" - window scrollbar acts like a scene scrubber
							// "false" - scene will be destroyed after the transform is fully finished
							// "0.95" (integer) - softens the link between the animation scene and the scrollbar
			transformOrigin: this.$el.attr('data-arts-parallax-transform-origin') || 'center center',
			// Effects based on the current scrolling speed
			velocity: {
				effect: this.$el.attr('data-arts-parallax-velocity-effect') || false,
				value: this.$el.attr('data-arts-parallax-velocity-value') || 0.0,
				unit: this.$el.attr('data-arts-parallax-velocity-unit') || 'deg'
			},
			resistance: this.$el.attr('data-arts-parallax-resistance') || 2 // Velocity animation type only
		};
		this.options = $.extend(true, {}, defaults, options, this.dataOptions);

		this.$scrubTarget = this.$el.find(this.options.target.scrub);
		this.scrubTarget = this.$scrubTarget.get(0);

		this.$velocityTarget = this.$el.find(this.options.target.velocity);
		this.velocityTarget = this.$velocityTarget.get(0);

		// change element to transform
		if (this.options.target.type === 'self') {
			this.$scrubTarget = this.$el;
		}

		// handle outer parallax element
		this.outerParallaxX = this.$el.closest('[data-arts-parallax-target][data-arts-parallax-x]').attr('data-arts-parallax-x');
		this.outerParallaxY = this.$el.closest('[data-arts-parallax-target][data-arts-parallax-y]').attr('data-arts-parallax-y');

		// Initial load
		this._init();
	}

	// Initial Method
	_init() {
		let
			factorScaleX = (1 + Math.abs(this.options.scrubbing.factor.x) * 2),
			factorScaleY = 1 + Math.abs(this.options.scrubbing.factor.y),
			factorScale = Math.max(factorScaleX, factorScaleY),
			factorToX = this.options.scrubbing.factor.x * 100,
			factorFromX = -1 * factorToX,
			factorToY = this.options.scrubbing.factor.y * 100,
			factorFromY = -1 * factorToY;

		if (factorFromX > 0 || factorFromY > 0) {
			factorScale = factorScale * factorScale;
		}

		// normal element
		if (this.options.target.type === 'self') {
			const scene = this._getScrubEffect({
				element: this.$el,
				fromX: this.options.scrubbing.translate.from.x,
				fromY: this.options.scrubbing.translate.from.y,
				toX: this.options.scrubbing.translate.to.x,
				toY: this.options.scrubbing.translate.to.y,
				fromScale: this.options.scrubbing.scale.from ? this.options.scrubbing.scale.from : false,
				toScale: this.options.scrubbing.scale.to ? this.options.scrubbing.scale.to : false,
				origin: this.options.transformOrigin,
				fromRotate: this.options.scrubbing.rotate.from ? this.options.scrubbing.rotate.from : false,
				toRotate: this.options.scrubbing.rotate.to ? this.options.scrubbing.rotate.to : false,
			});

			$.fn.artsParallax.scenes.push(scene);

			// background or <img> (do scale to prevent image edges exposing)
		} else {
			const scene = this._getScrubEffect({
				element: this.$scrubTarget,
				fromX: factorFromX + '%',
				fromY: factorFromY + '%',
				toX: factorToX + '%',
				toY: factorToY + '%',
				fromScale: this.options.scrubbing.scale.from ? this.options.scrubbing.scale.from : factorScale,
				toScale: this.options.scrubbing.scale.to ? this.options.scrubbing.scale.to : factorScale,
				origin: this.options.transformOrigin
			});

			$.fn.artsParallax.scenes.push(scene);
		}

		// velicty effect
		if (this.options.velocity.effect && this.options.velocity.value && this.options.velocity.unit) {
			const scene = this._getVelocityEffect({
				effect: this.options.velocity.effect,
				value: this.options.velocity.value,
				unit: this.options.velocity.unit
			});

			$.fn.artsParallax.scenes.push(scene);
		}
	}

	_getVelocityEffect({
		effect,
		value,
		unit
	}) {
		const
			$images = this.$el.add(this.$el.find('img')),
			scrollTrigger = {
				trigger: this.$el,
				start: 'top bottom',
				end: 'bottom top',
				scrub: this.options.scrub && this.options.scrub !== true ? parseFloat(this.options.scrub) : true,
				invalidateOnRefresh: true,
				refreshPriority: this.options.target.type === 'self' ? this.options.refreshPriority : this.options.refreshPriority + 10 // refresh possible inner parallax elements first
			};

		let scene;

		let
			factor = 0,
			proxy = {
				factor: 0
			},
			speed = this.options.resistance * 1000 * (value < 0 ? 1 : -1),
			setterPositive = gsap.quickSetter(this.$el, effect, unit),
			setterNegative,
			absValue = Math.abs(value),
			clamp = gsap.utils.clamp(-absValue, absValue);

			// try to find inner element for velocity effect
		if (this.$velocityTarget.is(this.$el)) {
			this.$velocityTarget = this.$el.find(this.options.target.velocity);
		}

		// has specified skew target
		if (this.$velocityTarget.length) {
			setterNegative = gsap.quickSetter(this.$velocityTarget, effect, unit);
		} else {
			setterNegative = gsap.quickSetter(this.$velocityTarget, effect, unit);
		}

		scrollTrigger.onUpdate = (instance) => {
			factor = clamp(instance.getVelocity() / speed);

			if (Math.abs(factor) > Math.abs(proxy.factor)) {
				proxy.factor = factor;

				gsap.to(proxy, {
					factor: 0,
					duration: 0.6,
					ease: 'power2',
					overwrite: true,
					onUpdate: () => {
						setterPositive(proxy.factor * 10);
						setterNegative(-proxy.factor * 10);
					},
				});
			};
		}

		scene = ScrollTrigger.create(scrollTrigger);

		// update scenes on image loaded
		if ($images.length) {
			$images.each(function () {
				$(this).on('load', () => {
					scene.refresh();
				});
			});
		}

		return scene;
	}

	_getScrubEffect({
		element,
		fromY,
		fromX,
		toY,
		toX,
		fromScale,
		toScale,
		fromRotate,
		toRotate,
		origin
	}) {
		const
			$images = this.$el.add(this.$el.find('img')),
			tl = new gsap.timeline(),
			scrollTrigger = {
				animation: tl.fromTo(element, {
					rotation: fromRotate || 0,
					y: fromY || 0,
					x: fromX || 0,
					scale: fromScale || 1,
					force3D: true,
					immediateRender: true
				}, {
					rotation: toRotate || 0,
					y: toY || 0,
					x: toX || 0,
					scale: toScale || fromScale || 1,
					transformOrigin: origin,
					force3D: true,
					ease: 'none'
				}),
				trigger: this.$el,
				start: 'top bottom',
				end: 'bottom top',
				scrub: this.options.scrub && this.options.scrub !== true ? parseFloat(this.options.scrub) : true,
				invalidateOnRefresh: true,
				refreshPriority: this.options.target.type === 'self' ? this.options.refreshPriority : this.options.refreshPriority + 10 // refresh possible inner parallax elements first
			};

		let scene;

		// waypoints adjustment for double vertical parallax
		if (this.outerParallaxY) {
			scrollTrigger.start = 'top bottom';
			scrollTrigger.end = () => `bottom+=${this.outerParallaxY} top`;
		}

		scene = ScrollTrigger.create(scrollTrigger);

		// update scene once inner images are loaded
		if ($images.length) {
			$images.each(function () {
				$(this).on('load', () => {
					scene.refresh();
				});
			});
		}

		return scene;
	}

}

// Wrapper for the plugin
$.fn.artsParallax = function (options) {
	const pluginName = "artsParallax";

	if (typeof gsap === 'undefined' || typeof ScrollTrigger === 'undefined') {
		console.error(`jQuery ${pluginName} plugin requires both GSAP and GSAP ScrollTrigger to work.`);
		return;
	}

	if (options === undefined || typeof options === 'object') {
		return this.each(function (index) {
			if (!$.data(this, pluginName)) {
				$.data(this, pluginName, new ArtsParallax(this, options));
			}
		});
	} else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
		const instance = $.data(this[0], pluginName);

		if (options === 'destroy') {
			$.data(this, pluginName, null);
		}

		if (instance instanceof ArtsParallax && typeof instance[options] === 'function') {
			return instance[options].apply(instance, Array.prototype.slice.call(arguments, 1));
		} else {
			return this;
		}
	}
};

// ScrollTrigger Scenes
$.fn.artsParallax.scenes = [];

$.fn.artsParallax.disableAll = function () {
	if ($.fn.artsParallax.scenes.length) {
		$.fn.artsParallax.scenes.forEach((scene) => {
			scene.animation.pause();
			scene.disable();
		});
	}
}

$.fn.artsParallax.enableAll = function () {
	if ($.fn.artsParallax.scenes.length) {
		$.fn.artsParallax.scenes.forEach((scene) => {
			scene.enable();
		});
	}
}

$.fn.artsParallax.refreshAll = function (args) {
	if ($.fn.artsParallax.scenes.length) {
		$.fn.artsParallax.scenes.forEach((scene) => {
			scene.refresh(args);
		});
	}
}

$.fn.artsParallax.destroyAll = function () {
	if ($.fn.artsParallax.scenes.length) {
		$.fn.artsParallax.scenes.forEach((scene) => {
			scene.animation.kill();
			scene.kill();
		});
		$.fn.artsParallax.scenes = [];
	}
}
});

