
/*!
 * jQuery Arts Split Text v1.0.0
 * 
 * @author: Artem Semkin
 * Â© 2021 All rights reserved.
 */

!function(n){"function"==typeof define&&define.amd?define(["jquery"],n):"object"==typeof module&&module.exports?module.exports=function(e,u){return void 0===u&&(u="undefined"!=typeof window?require("jquery"):require("jquery")(e)),n(),u}:n(jQuery)}(function(e){"use strict";
class ArtsSplitTextAnimations {
  constructor() {
    this.defaults = {
      duration: 1,
      ease: 'power4.out'
    };

    this._setLines();
    this._setWords();
    this._setChars();
    //
    this._animateChars();
    this._animateLines();
    this._animateWords();
    //
    this._hideChars();
    this._hideLines();
    this._hideWords();

    //
    this._animateText();
    this._hideText();
  }

  _setLines() {
    gsap.registerEffect({
      name: 'setLines',
      effect: (target, config) => {
        const
          $target = $(target),
          $lines = $target.find('.arts-split-text__line');

        if (!$lines.length) {
          return;
        }

        return gsap.set($lines, config);
      },
      defaults: {
        y: '100%'
      }
    });
  }

  _setWords() {
    gsap.registerEffect({
      name: 'setWords',
      effect: (target, config) => {
        const
          $target = $(target),
          $words = $target.find('.arts-split-text__word');

        if (!$words.length) {
          return;
        }

        return gsap.set($words, config);
      },
      defaults: {
        y: '100%'
      }
    });
  }

  _setChars() {
    gsap.registerEffect({
      name: 'setChars',
      effect: (target, config) => {
        const
          $target = $(target),
          $chars = $target.find('.arts-split-text__char');

        if (!$chars.length) {
          return;
        }

        return gsap.set($chars, config);
      },
      defaults: {
        y: '100%'
      }
    });
  }

  _animateChars() {
    gsap.registerEffect({
      name: 'animateChars',
      effect: (target, config) => {
        const
          tl = new gsap.timeline(),
          $target = $(target),
          $chars = $target.find('.arts-split-text__char');

        if (!$chars.length) {
          return tl;
        }

        if (config.duration === 0) {
          return gsap.effects.setChars($chars, config);
        }

        if (config.stagger && config.stagger.from && config.stagger.from === 'auto') {
          const textAlign = $target.css('text-align');
          let from;

          switch (textAlign) {
            case 'left':
              from = 'start';
              break;
            case 'center':
              from = 'center';
              break;
            case 'right':
              from = 'end';
              break;
            default:
              from = 'start';
              break;
          }

          config.stagger = this._distributeByPosition({
            from,
            amount: config.stagger.amount
          });
        }

        return tl.to($chars, config);
      },
      defaults: {
        x: '0%',
        y: '0%',
        autoAlpha: 1,
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        stagger: {
          from: 'auto',
          amount: 0.3
        },
      },
      extendTimeline: true,
    });
  }

  _animateLines() {
    gsap.registerEffect({
      name: 'animateLines',
      effect: (target, config) => {
        const $target = $(target);
        let $lines = $target.find('.arts-split-text__line');

        if (!$lines.length) {
          return;
        }

        if (config.duration === 0) {
          return gsap.effects.setLines($lines, config);
        }

        if (config.excludeEl) {
          $lines = $lines.not(config.excludeEl);
          delete config.excludeEl;
        }

        return gsap.to($lines, config);
      },
      defaults: {
        xPercent: 0,
        yPercent: 0,
        x: '0%',
        y: '0%',
        autoAlpha: 1,
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        stagger: {
          amount: 0.08
        }
      },
      extendTimeline: true,
    });
  }

  _animateWords() {
    gsap.registerEffect({
      name: 'animateWords',
      effect: (target, config) => {
        const
          $target = $(target),
          $words = $target.find('.arts-split-text__word');

        if (!$words.length) {
          return;
        }

        if (config.duration === 0) {
          return gsap.effects.setWords($words, config);
        }

        return gsap.to($words, config);
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        y: '0%',
        yPercent: 0,
        autoAlpha: 1,
        stagger: {
          amount: 0.2
        }
      },
      extendTimeline: true,
    });
  }

  _animateText() {
    gsap.registerEffect({
      name: 'animateText',
      effect: (target, config) => {
        const
          tl = new gsap.timeline(),
          $target = $(target),
          staggerLines = config.stagger.lines,
          staggerWords = config.stagger.words,
          staggerChars = config.stagger.chars,
          $list = $target.find('ul.has-split-list-items, ol.has-split-list-items'),
          $setLines = $target.filter('[data-arts-split-text-set="lines"]').add($target.find('[data-arts-split-text-set="lines"]')),
          $setWords = $target.filter('[data-arts-split-text-set="words"]').add($target.find('[data-arts-split-text-set="words"]')),
          $setChars = $target.filter('[data-arts-split-text-set="chars"]').add($target.find('[data-arts-split-text-set="chars"]'));

        if ($setLines.length) {
          config.stagger = staggerLines;
          tl.add(gsap.effects.animateLines($setLines, config), '0');
        }

        if ($setWords.length) {
          config.stagger = staggerWords;
          tl.add(gsap.effects.animateWords($setWords, config), '0');
        }

        if ($setChars.length) {
          tl.add(gsap.effects.animateChars($setChars, config), '0');
        }

        if ($list.length) {
          tl.add(() => {
            config.stagger = staggerChars;
            $list.addClass('has-split-list-items_animated');
          }, '0');
        }

        return tl;
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        stagger: {
          lines: {
            from: 'auto',
            amount: 0.3
          },
          words: {
            from: 'auto',
            amount: 0.2
          },
          chars: {
            from: 'auto',
            amount: 0.1
          }
        }
      },
      extendTimeline: true
    })
  }

  _hideChars() {
    gsap.registerEffect({
      name: 'hideChars',
      effect: (target, config) => {
        const
          $target = $(target),
          $chars = $target.find('.arts-split-text__char');

        if (!$chars.length) {
          return;
        }

        if (config.duration === 0) {
          return gsap.effects.setChars($chars, config);
        }

        if (config.stagger && config.stagger.from && config.stagger.from === 'auto') {
          const textAlign = $target.css('text-align');
          let from;

          switch (textAlign) {
            case 'left':
              from = 'start';
              break;
            case 'center':
              from = 'center';
              break;
            case 'right':
              from = 'end';
              break;
            default:
              from = 'start';
              break;
          }

          config.stagger = this._distributeByPosition({
            from,
            amount: config.stagger.amount
          });
        }

        if (config.duration === 0) {
          config.stagger = 0;
        }

        return gsap.to($chars, config);
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        autoAlpha: 1,
        stagger: 0,
        y: '-100%'
      },
      extendTimeline: true,
    });
  }

  _hideLines() {
    gsap.registerEffect({
      name: 'hideLines',
      effect: (target, config) => {
        const
          $target = $(target),
          $lines = $target.find('.arts-split-text__line');

        if (!$lines.length) {
          return;
        }

        if (config.duration === 0) {
          return gsap.effects.setLines($lines, config);
        }

        return gsap.to($lines, config);
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        y: '-100%',
        autoAlpha: 1,
        stagger: {
          amount: 0.02
        }
      },
      extendTimeline: true,
    });
  }

  _hideWords() {
    gsap.registerEffect({
      name: 'hideWords',
      effect: (target, config) => {
        const
          $target = $(target),
          $words = $target.find('.arts-split-text__word');

        if (!$words.length) {
          return;
        }

        if (config.duration === 0) {
          return gsap.effects.setWords($words, config);
        }

        return gsap.to($words, config);
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        y: '-100%',
        autoAlpha: 0,
        stagger: {
          amount: 0.02
        }
      },
      extendTimeline: true,
    });
  }

  _hideText() {
    gsap.registerEffect({
      name: 'hideText',
      effect: (target, config) => {
        const
          tl = new gsap.timeline(),
          $target = $(target),
          $setLines = $target.filter('[data-arts-split-text-set="lines"]').add($target.find('[data-arts-split-text-set="lines"]')),
          $setWords = $target.filter('[data-arts-split-text-set="words"]').add($target.find('[data-arts-split-text-set="words"]')),
          $setChars = $target.filter('[data-arts-split-text-set="chars"]').add($target.find('[data-arts-split-text-set="chars"]'));

        if ($setLines.length) {
          tl.add(gsap.effects.hideLines($setLines, config), '0');
        }

        if ($setWords.length) {
          tl.add(gsap.effects.hideWords($setWords, config), '0');
        }

        if ($setChars.length) {
          tl.add(gsap.effects.hideChars($setChars, config), '0');
        }

        return tl;
      },
      defaults: {
        duration: this.defaults.duration,
        ease: this.defaults.ease,
        stagger: {
          from: 'auto',
          amount: 0.07
        }
      },
      extendTimeline: true
    })
  }

  _distributeByPosition(vars) {
    let ease = vars.ease,
      from = vars.from || 0,
      base = vars.base || 0,
      axis = vars.axis,
      ratio = {
        center: 0.5,
        end: 1
      } [from] || 0,
      distances;
    return function (i, target, a) {
      if (!a) {
        return 0;
      }

      let l = a.length,
        originX, originY, x, y, d, j, minX, maxX, minY, maxY, positions;
      if (!distances) {
        distances = [];
        minX = minY = Infinity;
        maxX = maxY = -minX;
        positions = [];
        for (j = 0; j < l; j++) {
          d = a[j].getBoundingClientRect();
          x = (d.left + d.right) / 2; //based on the center of each element
          y = (d.top + d.bottom) / 2;
          if (x < minX) {
            minX = x;
          }
          if (x > maxX) {
            maxX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (y > maxY) {
            maxY = y;
          }
          positions[j] = {
            x: x,
            y: y
          };
        }
        originX = isNaN(from) ? minX + (maxX - minX) * ratio : positions[from].x || 0;
        originY = isNaN(from) ? minY + (maxY - minY) * ratio : positions[from].y || 0;
        maxX = 0;
        minX = Infinity;
        for (j = 0; j < l; j++) {
          x = positions[j].x - originX;
          y = originY - positions[j].y;
          distances[j] = d = !axis ? Math.sqrt(x * x + y * y) : Math.abs((axis === "y") ? y : x);
          if (d > maxX) {
            maxX = d;
          }
          if (d < minX) {
            minX = d;
          }
        }
        distances.max = maxX - minX;
        distances.min = minX;
        distances.v = l = vars.amount || (vars.each * l) || 0;
        distances.b = (l < 0) ? base - l : base;
      }
      l = (distances[i] - distances.min) / distances.max;
      return distances.b + (ease ? ease.getRatio(l) : l) * distances.v;
    };
  }
}
new ArtsSplitTextAnimations();


// Default Options
const defaults = {
  target: {
    dropCap: '.has-drop-cap',
    social: 'ul.social'
  },
  exclude: '',
  removeSplitClass: true,
  reduceWhiteSpace: true,
  wrapListElements: true,
  excludeListElements: '.post-meta__divider',
  setCharsDistribute: false,
  class: {
    overflow: '.overflow',
    line: '.arts-split-text__line',
    word: '.arts-split-text__word',
    char: '.arts-split-text__char',
  },
  overflow: {
    line: false,
    word: false,
    char: false,
  },
  animation: {
    duration: 1.2,
    ease: 'power3.out'
  }
};

class ArtsSplitText {

  constructor(element, options) {
    // Main container element
    this.$el = $(element);

    if (!this.$el.length) {
      return;
    }

    // Merge user settings with default
    this.dataOptions = {

    };
    this.options = $.extend(true, {}, defaults, options, this.dataOptions);

    // Initial load
    this._init();
  }

  // Initial Method
  _init() {
    const
      setType = this.$el.data('arts-split-text-set') || false,
      setDirection = this.$el.data('arts-split-text-set-direction') || 'y',
      setDistance = this.$el.data('arts-split-text-set-distance') || '100%',
      setOpacity = this.$el.data('arts-split-text-set-opacity'),
      setDistribute = this.$el.data('arts-split-text-set-distribute') || this.options.setCharsDistribute;
    let params = {
      autoAlpha: setOpacity
    };

    params[setDirection] = setDistance;

    this._split();

    switch (setType) {
      case 'lines':
        this._setLines({target: this.$el, params});
        break;
      case 'words':
        this._setWords({target: this.$el, params});
        break;
      case 'chars':
        this._setChars({target: this.$el, params, distribute: setDistribute});
      default:
        break;
    }
  }

  _split() {
    const
      type = this.$el.data('arts-split-text') || 'lines',
      overflowType = this.$el.data('arts-split-text-overflow-wrap');

    // handle possible children elements
    let $content = this._handleChildrenElements();

    // handle texts with drop cap
    this._handleDropCap();

    let
      linesClass = this.options.class.line.replace(/^\./, ''),
      wordsClass = this.options.class.word.replace(/^\./, ''),
      charsClass = this.options.class.char.replace(/^\./, ''),
      overflowClass = this.options.class.overflow.replace(/^\./, '');

    if (this.options.overflow.line) {
      linesClass += ` ${overflowClass}`;
    }

    if (this.options.overflow.word) {
      wordsClass += ` ${overflowClass}`;
    }

    if (this.options.overflow.char) {
      charsClass += ` ${overflowClass}`;
    }

    try {
      new SplitText($content, {
        type,
        linesClass,
        wordsClass,
        charsClass,
        reduceWhiteSpace: this.options.reduceWhiteSpace,
      });

      if (overflowType) {
        this._setOverflow({
          target: $content,
          type: overflowType,
          overflowClass
        });
      }

    } catch (error) {
      console.error(`SplitText error occurred while parsing the following HTML markup: "${this.innerHTML}"`);
    }

    this.$el.removeClass('js-arts-split-text');
  }

  _handleChildrenElements() {
    let
      self = this,
      $content = this.$el,
      $child = this.$el.children(`:not(br):not(${this.options.target.social})`); // child elements

    // split children elements if they exist
    // instead of the actual element
    if ($child.length > 0) {
      $content = $([]); // empty actual element
      $child.each(function () {
        const $this = $(this);

        // protect the lists with <span> wrappers
        if ($this.is('ul') || $this.is('ol') ) {
          $this.find('li').wrapInner('<div class="split-li-wrapper"></div>');
          $this.addClass('has-split-list-items');
        }

        // add the deepest child element to collection
        $content = $content.add(self._getDeepestChild($this));
      });
    }

    return $content;
  }

  _handleDropCap() {
    // find texts with drop cap
    const $contentWithDropcap = this.$el.find(this.options.target.dropCap);

    if ($contentWithDropcap.length) {
      $contentWithDropcap.each(function () {
        const
          $this = $(this),
          $thisHTML = $this.html(),
          firstChar = $this.text()[0];
        let $textContentWithDropcap;

        // drop cap paragraph has inner HTML markup
        if ($thisHTML) {
          $textContentWithDropcap = $thisHTML;
        } else { // drop cap paragraph is a plain text
          $textContentWithDropcap = $this.text();
        }

        // remove first char
        $this.html($textContentWithDropcap.substring(1));
        $this.prepend(`<span class="drop-cap">${firstChar}</span>`).addClass('has-drop-cap_split');
      });
    }
  }

  _setOverflow({
    target,
    type,
    overflowClass
  }) {
    if (!type || !target) {
      return;
    }

    const arrayType = type.split(',');

    if (arrayType.includes('lines')) {
      target.find(this.options.class.line).wrap(`<div class="${overflowClass}"></div>`);
    }
    if (arrayType.includes('words')) {
      target.find(this.options.class.word).wrap(`<div class="${overflowClass} d-inline-block"></div>`);
    }
    if (arrayType.includes('chars')) {
      target.find(this.options.class.char).wrap(`<div class="${overflowClass} d-inline-block"></div>`);
    }
  }

  _setLines({
    target,
    params = {}
  }) {
    if (!target || !target.length) {
      return;
    }

    return gsap.set(target.find(this.options.class.line), params);
  }

  _setWords({
    target,
    params = {}
  }) {
    if (!target || !target.length) {
      return;
    }
    return gsap.set(target.find(this.options.class.word), params);
  }

  _setChars({
    target,
    params = {},
    distribute = true
  }) {
    const self = this;
    if (!target || !target.length) {
      return;
    }

    gsap.set(target, {
      clearProps: 'all'
    });

    target.each(function () {
      const
      $el = $(this),
      $lines = $el.find(self.options.class.line),
      textAlign = $el.css('text-align');
      if (distribute) {
        switch (textAlign) {
          case 'left':
            self._setFromLeft({
              lines: $lines,
              params
            });
            break;
          case 'center':
            self._setFromCenter({
              lines: $lines,
              params
            });
            break;
          case 'right':
            self._setFromRight({
              lines: $lines,
              params
            });
            break;
        }
      } else {
        self._setFromLeft({
          lines: $lines,
          params
        });
      }
    });
  }

  _setFromLeft({
    lines,
    params = {}
  }) {
    if (!lines || !lines.length) {
      return;
    }
    gsap.set(lines.find(this.options.class.char), params);
  }

  _setFromRight({
    lines,
    params = {}
  }) {

    if (!lines || !lines.length) {
      return;
    }

    gsap.set(lines.find(this.options.class.char), this._getNegativeParams(params));
  }

  _setFromCenter({
    lines,
    params = {}
  }) {
    const self = this;

    if (!lines || !lines.length) {
      return;
    }

    lines.each(function () {
      const
        $currentLine = $(this),
        $wordsInCurrentLine = $currentLine.find(self.options.class.word);

      /**
       * 1. Only 1 word in the current line
       */
      if ($wordsInCurrentLine.length === 1) {
        self._setCharsSingleWord({
          words: $wordsInCurrentLine,
          params
        });
      }

      /**
       * 2. Even number of words in the current line
       */
      if ($wordsInCurrentLine.length !== 1 && $wordsInCurrentLine.length % 2 === 0) {
        self._setCharsEvenWords({
          words: $wordsInCurrentLine,
          params
        });
      }

      /**
       * 3. Odd number of words in the current line
       */
      if ($wordsInCurrentLine.length !== 1 && $wordsInCurrentLine.length % 2 !== 0) {
        self._setCharsOddWords({
          words: $wordsInCurrentLine,
          params
        });
      }
    });
  }

  _setCharsSingleWord({
    words,
    params = {}
  }) {
    const
      $charsInWord = words.find(this.options.class.char),
      halfWord = Math.ceil($charsInWord.length / 2),
      $fistHalfWord = $charsInWord.slice(0, halfWord),
      $secondHalfWord = $charsInWord.slice(halfWord, $charsInWord.length);

    // first half of word to the left
    gsap.set($fistHalfWord, this._getNegativeParams(params));

    // second half of word to the right
    gsap.set($secondHalfWord, params);
  }

  _setCharsOddWords({
    words,
    params = {}
  }) {
    const
      self = this,
      halfLine = Math.ceil(words.length / 2),
      $fistHalf = words.slice(0, halfLine),
      $secondHalf = words.slice(halfLine, words.length),
      $middleWord = words.eq(halfLine - 1),
      $charsInMiddleWord = $middleWord.find(this.options.class.char),
      halfLineMiddleWord = Math.ceil($charsInMiddleWord.length / 2),
      $fistHalfMiddleWord = $charsInMiddleWord.slice(0, halfLineMiddleWord),
      $secondHalfMiddleWord = $charsInMiddleWord.slice(halfLineMiddleWord, $charsInMiddleWord.length);

    // first half
    $fistHalf.each(function () {
      const $charsInWord = $(this).find(self.options.class.char);
      gsap.set($charsInWord, self._getNegativeParams(params));
    });

    // second half
    $secondHalf.each(function () {
      const $charsInWord = $(this).find(self.options.class.char);

      gsap.set($charsInWord, params);
    });

    // middle word: first half
    $fistHalfMiddleWord.each(function () {
      const $charsInWord = $(this);

      gsap.set($charsInWord, self._getNegativeParams(params));
    });

    // middle word: second half
    $secondHalfMiddleWord.each(function () {
      const $charsInWord = $(this);

      gsap.set($charsInWord, params);
    });
  }

  _setCharsEvenWords({
    words,
    params = {}
  }) {
    const
      self = this,
      halfLine = Math.ceil(words.length / 2),
      $fistHalf = words.slice(0, halfLine),
      $secondHalf = words.slice(halfLine, words.length);

    // second half
    $secondHalf.each(function () {
      const $charsInWord = $(this).find(self.options.class.char);

      gsap.set($charsInWord, params);
    });

    // first half
    $fistHalf.each(function () {
      const $charsInWord = $(this).find(self.options.class.char);

      gsap.set($charsInWord, self._getNegativeParams(params));
    });
  }

  _getDeepestChild($el) {

    if (!$el || !$el.length) {
      return [];
    }

    let $target, $next;

    const $children = $el.children().filter(function () {
      const $el = $(this);
      return !$el.is('br') && $el.css('display') !== 'inline-block';
    }); // exclude line breaks and inline-block elements

    // element doesn't have children
    // return actual element
    if (!$children.length) {
      return $el;
    }

    $target = $children;
    $next = $target;

    while ($next.length) {
      $target = $next;
      $next = $next.children();
    }

    return $target;
  }

  _getNegativeParams(params) {
    let result = { ...params };

    if ('x' in result) {
      result.x = result.x.replace(/^\-/, '');
      result.x = `-${result.x}`;
    }

    if ('y' in result) {
      result.y = result.y.replace(/^\-/, '');
      result.y = `-${result.y}`;
    }

    if ('z' in result) {
      result.z = result.z.replace(/^\-/, '');
      result.z = `-${result.z}`;
    }

    return result;
  }

}

// Wrapper for the plugin
$.fn.artsSplitText = function (options) {
  const pluginName = 'artsSplitText';

  if (typeof gsap === 'undefined') {
    console.error(`jQuery ${pluginName} plugin requires GSAP to work.`);
    return;
  }

  if (typeof SplitText === 'undefined') {
    console.error(`jQuery ${pluginName} plugin requires GSAP SplitText library to work.`);
    return;
  }

  if (options === undefined || typeof options === 'object') {
    return this.each(function () {
      if (!$.data(this, pluginName)) {
        $.data(this, pluginName, new ArtsSplitText(this, options));
      }
    });
  } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
    const instance = $.data(this[0], pluginName);

    if (options === 'destroy') {
      $.data(this, pluginName, null);
    }

    if (instance instanceof ArtsSplitText && typeof instance[options] === 'function') {
      return instance[options].apply(instance, Array.prototype.slice.call(arguments, 1));
    } else {
      return this;
    }
  }
};
});
